<?xml-stylesheet type="text/xsl" href="XSL/Todo.xsl" ?> 
<topics
	 xmlns:r="http://www.r-project.org">

<topic>
<title>Things To Note</title>
<items>

<item>
Query parameters on Argument.
</item>

<item>
Remove an attribute on a Argument or Function.
removeAttr() method in Argument.
</item>

<item>
Methods to create the Instruction classes  that were missing.
<r:output><![CDATA[
 [1] "IndirectBrInst"     "ResumeInst"         "UnreachableInst"   
 [4] "FenceInst"          "AtomicCmpXchgInst"  "AtomicRMWInst"     
 [7] "TruncInst"          "ZExtInst"           "FPToUIInst"        
[10] "FPToSIInst"         "UIToFPInst"         "SIToFPInst"        
[13] "FPTruncInst"        "FPExtInst"          "PtrToIntInst"      
[16] "IntToPtrInst"       "BitCastInst"        "ICmpInst"          
[19] "FCmpInst"           "PHINode"            "SelectInst"        
[22] "VAArgInst"          "ExtractElementInst" "InsertElementInst" 
[25] "ShuffleVectorInst"  "ExtractValueInst"   "InsertValueInst"   
[28] "LandingPadInst"    
]]></r:output>
</item>

<item status="done">
Do we need the specific methods for getOperands, etc.??
Don't think so!
</item>

<item>
test getCppClasses().  Use inst/TU/clang.R.  Failing in assigning params
for Links.
</item>

<item>
Setting attribute on an argument requires now to specify the
index of the argument, first arugment starting at 1 in C++.
</item>

<item>
Ways to get the specific instruction type,
e.g. when getOperand(), just get back generic Value object.
Could use dynamic casts and exhaustively find one that works!
</item>

<item>
Build on Windows
</item>


<item>
update the enums for 3.3. The TypeIDs were off. Manually fixed.
<br/>
Need to make the old ones for llvm 3.2 available for installation.
<br/>
BinaryOps, FuncAttributes, ICmpInst.Predicate (in ICmpEnums.R)
CastOps (Trunc, ZExt, etc.), IntrinsicIDs, TypeIDEnums,
LinkageType , CodeGenOpt, {VoidType, etc.} in typeDefs.R
</item>

<item>
See how to generate C++ from the IR, and also  PTX.

http://llvm.org/docs/NVPTXUsage.html
</item>


<item>
reinforced random walk, BML examples
</item>

<item>
Make declareFunction accept a Type, list(Type, Type) 
rather than just a single list() with the return type and parameter types.
</item>

<item>
When we read IR back into R, lose the specific SEXP type information on the function.
</item>


<item>
When a parameter type is one of the SEXP types, then coerce the input to that type.
Perhaps too much overhead. Also, we just have the generic SEXPType 
at this point.  Could create derived C++ classes to represent the different types
or a single one that had the SEXP type(of). Then the types wouldn't necessarily be unique.
But can make it so. Just use a static method to get it for the different sexp types.
<br/>
Try to find a way to get the different SEXP types as their own
types but compatible with the generic SEXP type.
Could cast.
</item>

<item>
How to handle a struct as a parameter.
Have to match the ABI.
Does it depend on the nature of the elements of the struct.
</item>

<item status="low">
[Needs to be implemented in LLVM]
Allow calling varargs functions directly.
See varargs.R
<r:code>
.llvm(pf, "result: %d ***\n", 34L)
</r:code>
Currently, runFunction in LLVM doesn't support this.
Assertion: "This doesn't support passing arguments through varargs (yet)!"
</item>


<item>
Add a finalizer routine to a Module and when we garbage collect it, 
then we can call it.
This can release global variables in the module, e.g. regular expressions.
Have to ensure that no elements of the module are still assigned in R.
Maybe borrow code from RCIndex for reference counting.
</item>

<item status="finish">
R print method for Function to show the signature. 
<r:func>getTypeName</r:func>.
Possibly for Module also, e.g. to show the names of the elements, perhaps their type.
</item>

<item>
get attributes for a Function object. 
See funcAttributes.R.
Problem with a spurious number appearing at end 'nocapture align 1073741824'.
Are we setting these on the functions when we are supposed to be setting on a parameter.
If we just set NoUnwind, then things are fine.
really make sense.
Resulting IR cannot be read.
<br/>
[Done] How do we work with the AttrListPtr.
</item>

<item>
Allow Adding passes to the pass manager - e.g. the AlwaysInlinerPass.
addPass() function exists.
Constructors for different passes.
</item>

<item>
InitializeNVPTXTarget() and generating code for PTX.

See https://github.com/halide/Halide/blob/master/src/cllutil.c

<ol>
<li>initialize the NVPTXTarget.</li>
<li>set the triple on the module</li>
<li>lookupTarget(triple)</li>
<li>create and fill in a TargetOptions struct</li>
<li>create the TargetMachine object (TheTarget->createTargetMachine())</li>
<li>create, fill in and then run pass manager. Set targetLibraryInfo in the PassManager,
along with other information from the machine and module</li>
</ol>

How do we get the code back from LLVM so that we can pass it to CUDA?
How do we run the code on the GPU?
Can we use cuModuleLoadData?
Can we get the address of the function from the execution engine?
<br/>
See libNVVM.
</item>


<item status="done">
Should use the pointer for the global variable to set it,
just like we do when we get it. We need the type.
<r:code>
library(Rllvm)
InitializeNativeTarget()
mod = Module("global")
mod[["status"]] = TRUE
showModule(mod)
</r:code>
doesn't set the value if the variable has already been created.
It only sets it the first time.
Actually it creates a new variable with a 1 added to the name!
<r:code>
library(Rllvm)
InitializeNativeTarget()
mod = Module("global")
mod[["status"]] = TRUE
showModule(mod)
setInitializer(mod[["status"]], createLogicalConstant(FALSE))
showModule(mod)
mod[["status"]] = TRUE
</r:code>
<br/>

The getGlobalVariable() functions and the setting of these values
don't behave as expected. The get() function gets the initial value.
The set values don't set the variable if it already exists.
This will change in the future.
The get value doesn't get the new value, just the initialization value.
See tests/clone2.R
<br/>
This is probably just a mistaken understanding/analysis of the outcomes.
Need to use the same Execution Engine to see the changes.

</item>

<item status="done">
Fix getting function attributes for 3.2
(Getting back a list with an element for each attribute,
but each has the entire set.
Working on the slots.)
</item>

<item status="done">
[Basically done but ... and test with 3.2]
[need to update enums  - AttrKind for FuncAttributes]
[configuration done]

sort out the changes to the Attributes and AttributeSet.
Determine in configure what we are dealing with and
set NEW_LLVM_ATTRIBUTES_SETUP appropriately
and export to Makevars.in.
<br/>
Things compile now for 3.3, but don't work. tests/funcAttributes.R
For add.ll, settings on foo are returning correctly from query.
But setting is not working.  It is if we update the enum  values.
</item>

<item status="done">
Problem reading llvm header files with RCIndex.
Issue is with cstddef file not found and when we point it to
one of the ones on a mac, we get errors.
<br/>
Need the -xc++ argument for  libclang to force C++.
</item>



</items>
</topic>

<topic>
<title>Main</title>
<items>

<item>
Set alignment for parameters and arguments.
</item>

<item>
Implement the set ByVal as a function 
<br/>
Done but decide name - now setArgByVal().
</item>

<item>
parseIR() needs to give an error message saying what the problem is.
Problem with the string only. That causes the entire message  not to be displayed.
</item>


<item>
Reset a global variable in a module
<br/>
e.g. explorations/clangHandler.R - ctr
<r:code>
mod[["ctr", ee = ee]] = 0L
</r:code>
</item>

<item>
shutdown LLVM.
</item>

<item status="done">
Dynamically retrieve LLVM version information. See <r:func>llvmVersion</r:func>
</item>

<item>
strings &amp; string constants.
</item>

<item>
Should m[["notexists"]] for a Module m raise an error or return NULL.
<br/>
If we want to have a check if a symbol is in a module, we can use %in%:
<r:code>
setMethod("%in%", c("character", "Module"), function(x, table)  x %in% names(table))
</r:code>
</item>

<item status="check">
getGlobalValue() of a pointer to a string  doesn't work.
See explorations/globalString.R and 
specifically 
<r:code>
getGlobalValue(m[["str1_p"]], ee) # does not work
</r:code>
Do we have to dereference the pointer to get the actual
address of the data?
Seems fixed now (in git: 19ca87e)
</item>

<item>
Function to link two or more modules
so that we can compile functions separately and then
allow them to refer to each other.
Perhaps hierarchies of modules?
Use addGlobalMapping() explicitly to connect one routine to another module?
No, use the Linker::LinkModules() method?
What about the need for external linkage, the declaration, etc.
when we make a call to the routine that isn't in the module.
<br/>
We can insert new modules into the execution engine. See addModule().
We also would like to pass the compiler a collection
of modules so that it can find existing Functions in those.
</item>

<item>
Rf_length and other routines not available via getNativeSymbolInfo()
except on OS X. Have to find another way to access them to be able to
invoke them from LLVM.
Perhaps we can persuade the LLVM linker to use the 
libR.{so,Rdylib}
<xml:ns></xml:ns></item>

<item status="low">
Compile access to R connections.
</item>

<item>
Example of accessing a struct.
Example of working with an existing struct type in C
and compile code to operate on it.
Issues with ensuring alignment and padding if compiled by another compiler.
<br/>
See examples of working with a pointer to a libclang CXCursor.
</item>

<item>
When converting SEXPs to and from GVs in C code,
use the actual target SEXP type and not just the generic type.
Similar/Related to registering routines with R and checking the types in a .Call().
</item>

<item>
varargs
</item>


<item>
Metadata
</item>

<item status="done">
getTypeID should return the name of the type, not just the enum
value.
</item>

<item>
??? See llvmpy, (tests/JUTTutorial2.py)
Is this what is actually going on in that example or are we jumping to that block????
</item>


<item>
Write out [Done] bitcode, [Done] llvm module (IR or ?), 
shared object (need linker step - system or in LLVM API?)
See pycc.
</item>

<item>
structures
getStructName()  (getName() in R), 
getElementTypes equivalent to getStructElementType(), getStructNumElements() in C++.
How to create them?  structType() function in R.
</item>


<item>
Navigate/traverse the tree of blocks, instructions,
and the ability to remove and insert instructions and
blocks.
<br/>
C code to erase from parent for BasicBlock and Instruction.
</item>



<item pkg="RGCCTranslationUnit">
In the TU, ExecutionEngine create method has an NA for the type of one of the parameters.
The type is there and the name of the type is also there, just not shown.
<r:code>
system.time({tu = parseTU("inst/TU/llvm.c.001t.tu")})
k = getClassNodes(tu)
m = getClassMethods(k[["llvm::ExecutionEngine"]])
rm = resolveType(m, tu)
</r:code>
</item>

<item status="low" pkg="RGCCTranslationUnit">
In TU  (RGCCTranslationUnit)
<r:code>
m = getClassMethods(k[["llvm::BasicBlock"]])
<r:error>
Error in getClass("GCC::Node::offset_type") : 
  "GCC::Node::offset_type" is not a defined class
</r:error>
</r:code>
<br/>
Do this in RClang now.
</item>

<item status="done">
getOperand() method.
It would be nice to be able to do to the LLVM instructions
what we can do to R language objects. ???
Walk them ?
<br/>
And add  [[ method.
</item>

<item>
How do we get the names of the elements on a struct Type?
Do we add this in meta-data?
</item>

<item>
{g,s}etCallingConv(), hasUWTable(), doesnNotThrow()/setDoesNotThrow(), getEntryBlock(), getBasicBlockList().
</item>
<item>
C routine to get Context from a Function to avoid going to the Module.
</item>

<item status="done">
set attributes on a function, e.g. unwind , stack protect, UWTable (?)
 func->setAttributes()  AttrBuilder B b.addAttribute(Attribute::NoUnwind)
See a .llcpp example.
</item>

<item>
Methods for IRBuilder
<br/>
See the TU interface generation.
<br/>
[gone] CreateUnwind, 

?CreateNeg, CreateNot ?

CreateAnd, CreateOr, CreateXor
CdcreateShr/Shl

CreateUnreachable
CreateVAArg


CreateIndirectBr (indirect branch), 
CreateAggregateRet (return multiple values), 

CreateNSWAdd, NUWAdd, NSWSub, ...   - NSW = No signed wrap, NUW = NoUnsignedWrap.
CreateTrunc (truncate integer),   - [Done] perhaps a general function for CreateCast(). Is the first argument an enum or an object.
CreateInboundsGEP  (is this equivalent getGetElementPtr?)

All of the SExtOrOther, etc. methods.


[Test] CreateInvoke - allows continuation to branch based on how the called function returns - normal or resume.


[done] CreateZExt (zero extension of integer), CreateSExt (sign extension of integer)
[Done] CreateSwitch (multiway switch) - addCase,
[Done] CreatePtrDiff
[Done] CreatePHI
[Done] CreateIsNull, CreateIsNotNull
[Done] CreateExtractElemet
[Done] CreateInsertElement
[Done] CreateSelect   - ternary operator
</item>

<item>
Also allow passing in a function pointer to an LLVM generated
routine as a type of argument, i.e. a function pointer.
For example, the distance computation where we specify the 
metric to use for the two observations.
<br/>
How do we specify that sort of type?
<br/>

</item>

<item>
Make certain that errors don't abort R.
Is this just compiling w/o assertions.
We should also check all constraints in R or C++ code before
calling the C++ methods.
</item>

<item>
Add checks on the call stack (like R's interpreter) and segfaults 
and ensure  recovery. 
We can do this with inbound array checks, but there are other sources.
</item>



<item status="checkDone">
create a GEP with inbounds.
<br/>
Need to specify the indices in the constructor.
Call IRBuilder-&gt;CreateInBoundsGEP
</item>

<item status="fix"> [Close but not working]
global variables. Get the value.  Write a routine to get them.  Can't
we do this generically.
<br/>
Use the ExecutionEngine and its  methods
<r:code>
library(Rllvm)
mod = Module("globalTest")
ee = ExecutionEngine(mod)
id = "i"
mod[[id]] = pi
mod[[id]]
ptr = Rllvm:::getPointerToGlobal(mod[[id]], ee)
type = getType(mod[[id]])
ty = getElementType(type)
getGlobalValue(mod[[id]], ee)
</r:code>
See tests/globalGet.R
</item>

<item>
When we specify the initializer for a global variable
and it is an array, we have to make certain the length of the 
array matches.  
Ensure this in createGlobalVariable() when val is specified.
</item>

<item>
function to create an opaque type, e.g. pointerType(opaqueType())
</item>


<item>
dump a module to a buffer.
or createPrintModulePass to our buffer.
<br/>
Is this just showModule()?
</item>

<!-- "Dones" -->

<item status="done">
Get module's name via getName() method.
</item>

<item status="done">
makeRFunction to create a wrapper for an LLVM routine.
</item>



<item status="done">
[Done] Read bitcode (.bc) into a Module.
readBitCode.
[Done] Should be able to read from a raw also.
</item>


<item status="done">
Call a generated routine via Rffi or .Call()/.C()
<br/>
Use getPointerToFunction().
See tests/rffiCall.Rdb.
Crashing now.
See the second example in rffiCall.Rdb
<br/>
</item>

<item status="done">
Within a routine, call an existing routine in a DSO.
<br/>
Need to help out the resolving of routines.
<br/>
Ideally we would like to call the R engine
to resolve a symbol. However, for now
we can require that the caller
register symbols or DLLs.
</item>

<item status="done">
Clone a module - see llvmpy
<br/>
clone() generic and method for Module.
</item>

<item status="done">
module to native assembly - is this the IR?
If so, then simply showModule() or as(module, "character").
For creating bit code, use writeBitcode
</item>

<item status="done">
From assembly string? Done?
ParseAssemblyString.
And from IR, use parseIR
</item>
<item status="done">
Get element type of a pointer, array or vector type.
getPointerElementType(), getVectorElementType(), getArrayElementType(), etc.
</item>

<item status="done">
Find out how to parse IR text into IR structures.
<br/>
ParseIRFile() in opt.cpp.
So Support/IRReader.h
<br/>
For BitCode, see  include/llvm/Bitcode/ReaderWriter.h
</item>

<item status="done">
IRBuilder has a $ method so we can use
 ir$createICmp(), ir$createRet(), etc.
a la C++ invocation.
</item>

<item status="done">
[YES] Does assigning to the global variable actually set it - YES!
<r:code>
library(Rllvm)
mod = Module("globalTest")
mod[["i"]] = pi
</r:code>
Doesn't seem to.
</item>

<item status="done">
When the routine's  return type is VoidType, make certain
we get a terminator.
<br/>
See fgets.Rdb and change the return type to VoidType
</item>

<item status="done">
Where is the default value of mod coming from? .RData
</item>

<item status="done">
When passed an argument that is supposed to be a pointer,
if it is not an externalptr, but isS4, look for a @ref slot.
</item>


<item status="done">
Move createProxy to RLLVMCompile or declareFunction from there to Rllvm.
<br/>
Moved declareFunction to Rllvm.
</item>

<item status="done">
Find out how to call a routine that is dynamically loaded from another .so
We are using addGlobalMapping(), but that doesn't seem to be working
See RLLVMCompile/tests/dynLoadCall.R
<br/>
Already working. I just broke it when allowing strings as arguments to get NativeSymbolInfo values.
</item>

<item status="done">
Find out how to create and export INTSXPType (=getSEXPType("INT")) in the onLoad()
function. The struct class is not available then apparently.
</item>

<item status="done">
save module's IR to a string. Done already?
Yes, showModule( , TRUE)
</item>

</items>
</topic>
</topics>
